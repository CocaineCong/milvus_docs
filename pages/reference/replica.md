


<!--
# In-Memory Replica

本主题介绍了 Milvus 中的内存副本（复制）机制，它可以在工作内存中进行多个段的复制，以提高性能和可用性。

## 概述

![Replica_Availiability](/assets/replica_availability.jpg "In-memory replicas improve system availability.")

使用内存副本，Milvus 可以在多个查询节点上加载相同的段。如果一个查询节点在另一个查询到达时发生故障或忙于当前搜索请求，系统可以将新请求发送到具有相同段的空闲查询节点。

### 性能

内存副本允许你利用额外的 CPU 和内存资源。如果你有一个相对较小的数据集，但希望利用额外的硬件资源来增加读取吞吐量，这是非常有用的。整体 QPS（每秒查询数）和吞吐量可显着提高。

### 可用性

内存副本有助于 Milvus 在查询节点崩溃时更快地恢复。当查询节点失败时，不需要在另一个查询节点上重新加载段。相反，可以立即将搜索请求重新发送到新的查询节点，而无需重新加载数据。通过同时维护多个段副本，系统在故障切换面前更具弹性。

## 关键概念

内存副本以副本组的方式组织。每个副本组都包含 [分片](https://milvus.io/docs/v2.1.x/glossary.md#Sharding) 副本。每个分片副本都有一个流式副本和历史副本，它们对应于分片（即 DML 通道）中的增长和封存段。

![内存副本工作原理示意图](/assets/replica_availability.jpg)

### 副本组

一个副本组由多个负责处理历史数据和副本的 [查询节点](https://milvus.io/docs/v2.1.x/four_layers.md#Query-node) 组成。

### 分片副本

一个分片副本包含一个流式副本和一个历史副本，它们都属于同一个 [分片](https://milvus.io/blog/deep-dive-1-milvus-architecture-overview.md#Shard)。一个副本组中的分片副本数量由指定集合中的分片数量确定。

### 流式副本

流式副本包含同一 DML 通道中的所有 [增长段](https://milvus.io/docs/v2.1.x/glossary.md#Segment)。从技术上讲，一个流式副本应该由一个查询节点在一个副本中提供服务。

### 历史副本

历史副本包含同一 DML 通道中的所有封存段。一个历史副本的封存段可以分布在同一个副本组内的多个查询节点上。

### 分片领导者

分片领导者是在分片副本中为流式副本提供服务的查询节点。

## 设计详解

### 平衡

需要加载的新段将被分配给多个不同的查询节点。只要有一个副本加载成功，查询请求就可以被处理。

### 搜索

#### 缓存

代理维护一个将段映射到查询节点的缓存，并定期更新。当代理接收到请求时，Milvus 从缓存中获取所有需要搜索的封存段，并试图将它们均匀分配给查询节点。

对于增长段，代理还维护一个通道到查询节点的缓存，并向对应的查询节点发送请求。

#### 故障转移

代理上的缓存并不总是最新的。当请求到达时，某些段或通道可能已经被移动到其他查询节点上。这种情况下，代理将接收到错误响应，更新缓存，并尝试将其分配给另一个查询节点。

如果代理在更新缓存后仍然找不到段，将忽略该段。如果段已经被压缩，就可能发生这种情况。

如果缓存不准确，代理可能会错过一些段。具有 DML 通道（增长段）的查询节点返回包含可靠段列表的搜索响应，代理可以用这些列表进行比较并更新缓存。

### 增强



# 
代理无法将搜索请求完全均匀地分配给查询节点，并且查询节点可能具有不同的资源来提供搜索请求的服务。为了避免资源的长尾分布，代理将将其他查询节点上的活动片段分配给具有这些片段的空闲查询节点。

