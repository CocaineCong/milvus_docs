# 内存副本

本文介绍了 Milvus 中的内存副本（复制）机制，该机制通过在工作内存中实现多个段的复制来提高性能和可用性。

## 概述

![副本可用性](/replica_availability.jpg "内存副本提高系统可用性。")

通过内存副本，Milvus 可以在多个查询节点上加载相同的段。如果一个查询节点发生故障或在当前搜索请求忙碌时，当另一个请求到达时，系统可以将新请求发送到具有相同段副本的空闲查询节点。

### 性能

内存副本允许您利用额外的 CPU 和内存资源。如果您的数据集相对较小，但希望使用额外的硬件资源增加读取吞吐量，这非常有用。总体 QPS（每秒查询次数）和吞吐量可以显著提高。

### 可用性

内存副本帮助 Milvus 在查询节点崩溃时更快地恢复。当查询节点失败时，不需要在另一个查询节点上重新加载段。相反，搜索请求可以立即重新发送到新的查询节点，而不必再次重新加载数据。通过同时维护多个段副本，系统在面对故障转移时更具弹性。

## 关键概念

内存副本以副本组的形式组织。每个副本组包含 [分片](https://milvus.io/docs/v2.1.x/glossary.md#Sharding) 副本。每个分片副本都有一个流副本和一个历史副本，分别对应于分片中（即 DML 通道）的增长和密封 [段](https://milvus.io/docs/v2.1.x/glossary.md#Segment)。

![内存副本工作原理的插图](/replica_availability.jpg)

### 副本组

副本组由多个 [查询节点](https://milvus.io/docs/v2.1.x/four_layers.md#Query-node) 组成，负责处理历史数据和副本。

### 分片副本

分片副本由一个流副本和一个历史副本组成，两者都属于同一个 [分片](https://milvus.io/blog/deep-dive-1-milvus-architecture-overview.md#Shard)。副本组中分片副本的数量由指定集合中的分片数量决定。

### 流副本

流副本包含来自同一 DML 通道的所有 [增长段](https://milvus.io/docs/v2.1.x/glossary.md#Segment)。从技术上讲，一个流副本应该只由一个副本在一个副本中提供服务。

### 历史副本

历史副本包含来自同一 DML 通道的所有密封段。一个历史副本的密封段可以在同一个副本组内的多个查询节点上分布。

### 分片领导者

分片领导者是为分片副本中的流副本提供服务的查询节点。

## 设计细节

### 平衡

需要加载的新段将被分配到多个不同的查询节点。一旦至少一个副本成功加载，就可以处理搜索请求。

### 搜索

#### 缓存

代理维护一个将段映射到查询节点的缓存，并定期更新它。当代理接收到请求时，Milvus 从缓存中获取所有需要搜索的密封段，并尝试将它们均匀地分配给查询节点。

对于增长段，代理还维护一个通道到查询节点的缓存，并将请求发送到相应的查询节点。

#### 故障转移

代理上的缓存并不总是最新的。当请求进来时，一些段或通道可能已经被移动到其他查询节点。在这种情况下，代理将收到错误响应，更新缓存并尝试将其分配给另一个查询节点。

如果代理在更新缓存后仍然找不到段，将忽略该段。如果段已经被压缩，这种情况可能会发生。

如果缓存不准确，代理可能会错过一些段。具有 DML 通道（增长段）的查询节点返回搜索响应以及代理可以比较和更新缓存的可靠段列表。

### 增强

代理不能完全平等地将搜索请求分配给查询节点，查询节点可能具有不同的资源来提供搜索请求。为了避免资源的长尾分布，代理将把其他查询节点上的活动段分配给也有这些段的空闲查询节点。